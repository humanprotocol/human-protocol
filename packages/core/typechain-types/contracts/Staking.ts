/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export declare namespace IStaking {
  export type AllocationStruct = {
    escrowAddress: PromiseOrValue<string>;
    staker: PromiseOrValue<string>;
    tokens: PromiseOrValue<BigNumberish>;
    createdAt: PromiseOrValue<BigNumberish>;
    closedAt: PromiseOrValue<BigNumberish>;
  };

  export type AllocationStructOutput = [
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    escrowAddress: string;
    staker: string;
    tokens: BigNumber;
    createdAt: BigNumber;
    closedAt: BigNumber;
  };
}

export declare namespace Stakes {
  export type StakerStruct = {
    tokensStaked: PromiseOrValue<BigNumberish>;
    tokensAllocated: PromiseOrValue<BigNumberish>;
    tokensLocked: PromiseOrValue<BigNumberish>;
    tokensLockedUntil: PromiseOrValue<BigNumberish>;
  };

  export type StakerStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    tokensStaked: BigNumber;
    tokensAllocated: BigNumber;
    tokensLocked: BigNumber;
    tokensLockedUntil: BigNumber;
  };
}

export interface StakingInterface extends utils.Interface {
  functions: {
    "allocate(address,uint256)": FunctionFragment;
    "allocations(address)": FunctionFragment;
    "closeAllocation(address)": FunctionFragment;
    "getAllocation(address)": FunctionFragment;
    "getAllocationState(address)": FunctionFragment;
    "getListOfStakers()": FunctionFragment;
    "getStakedTokens(address)": FunctionFragment;
    "getStaker(address)": FunctionFragment;
    "hasAvailableStake(address)": FunctionFragment;
    "hasStake(address)": FunctionFragment;
    "initialize(address,uint256,uint32)": FunctionFragment;
    "isAllocation(address)": FunctionFragment;
    "lockPeriod()": FunctionFragment;
    "minimumStake()": FunctionFragment;
    "owner()": FunctionFragment;
    "proxiableUUID()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "rewardPool()": FunctionFragment;
    "setLockPeriod(uint32)": FunctionFragment;
    "setMinimumStake(uint256)": FunctionFragment;
    "setRewardPool(address)": FunctionFragment;
    "slash(address,address,address,uint256)": FunctionFragment;
    "stake(uint256)": FunctionFragment;
    "stakers(uint256)": FunctionFragment;
    "stakes(address)": FunctionFragment;
    "token()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "unstake(uint256)": FunctionFragment;
    "upgradeTo(address)": FunctionFragment;
    "upgradeToAndCall(address,bytes)": FunctionFragment;
    "withdraw()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "allocate"
      | "allocations"
      | "closeAllocation"
      | "getAllocation"
      | "getAllocationState"
      | "getListOfStakers"
      | "getStakedTokens"
      | "getStaker"
      | "hasAvailableStake"
      | "hasStake"
      | "initialize"
      | "isAllocation"
      | "lockPeriod"
      | "minimumStake"
      | "owner"
      | "proxiableUUID"
      | "renounceOwnership"
      | "rewardPool"
      | "setLockPeriod"
      | "setMinimumStake"
      | "setRewardPool"
      | "slash"
      | "stake"
      | "stakers"
      | "stakes"
      | "token"
      | "transferOwnership"
      | "unstake"
      | "upgradeTo"
      | "upgradeToAndCall"
      | "withdraw"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "allocate",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "allocations",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "closeAllocation",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllocation",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllocationState",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getListOfStakers",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStakedTokens",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getStaker",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasAvailableStake",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasStake",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isAllocation",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "lockPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minimumStake",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardPool",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setLockPeriod",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinimumStake",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setRewardPool",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "slash",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "stake",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakers",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakes",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "token", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "unstake",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "withdraw", values?: undefined): string;

  decodeFunctionResult(functionFragment: "allocate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "allocations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "closeAllocation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllocation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllocationState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getListOfStakers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakedTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getStaker", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "hasAvailableStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hasStake", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isAllocation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "lockPeriod", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "minimumStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rewardPool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setLockPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMinimumStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRewardPool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "slash", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stake", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stakers", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stakes", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "token", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unstake", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "AdminChanged(address,address)": EventFragment;
    "AllocationClosed(address,uint256,address,uint256)": EventFragment;
    "BeaconUpgraded(address)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "SetLockPeriod(uint32)": EventFragment;
    "SetMinumumStake(uint256)": EventFragment;
    "SetRewardPool(address)": EventFragment;
    "StakeAllocated(address,uint256,address,uint256)": EventFragment;
    "StakeDeposited(address,uint256)": EventFragment;
    "StakeLocked(address,uint256,uint256)": EventFragment;
    "StakeSlashed(address,uint256,address,address)": EventFragment;
    "StakeWithdrawn(address,uint256)": EventFragment;
    "Upgraded(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllocationClosed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BeaconUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetLockPeriod"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetMinumumStake"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetRewardPool"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeAllocated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeDeposited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeLocked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeSlashed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeWithdrawn"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<
  [string, string],
  AdminChangedEventObject
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface AllocationClosedEventObject {
  staker: string;
  tokens: BigNumber;
  escrowAddress: string;
  closedAt: BigNumber;
}
export type AllocationClosedEvent = TypedEvent<
  [string, BigNumber, string, BigNumber],
  AllocationClosedEventObject
>;

export type AllocationClosedEventFilter =
  TypedEventFilter<AllocationClosedEvent>;

export interface BeaconUpgradedEventObject {
  beacon: string;
}
export type BeaconUpgradedEvent = TypedEvent<
  [string],
  BeaconUpgradedEventObject
>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface SetLockPeriodEventObject {
  lockPeriod: number;
}
export type SetLockPeriodEvent = TypedEvent<[number], SetLockPeriodEventObject>;

export type SetLockPeriodEventFilter = TypedEventFilter<SetLockPeriodEvent>;

export interface SetMinumumStakeEventObject {
  minimumStake: BigNumber;
}
export type SetMinumumStakeEvent = TypedEvent<
  [BigNumber],
  SetMinumumStakeEventObject
>;

export type SetMinumumStakeEventFilter = TypedEventFilter<SetMinumumStakeEvent>;

export interface SetRewardPoolEventObject {
  rewardPool: string;
}
export type SetRewardPoolEvent = TypedEvent<[string], SetRewardPoolEventObject>;

export type SetRewardPoolEventFilter = TypedEventFilter<SetRewardPoolEvent>;

export interface StakeAllocatedEventObject {
  staker: string;
  tokens: BigNumber;
  escrowAddress: string;
  createdAt: BigNumber;
}
export type StakeAllocatedEvent = TypedEvent<
  [string, BigNumber, string, BigNumber],
  StakeAllocatedEventObject
>;

export type StakeAllocatedEventFilter = TypedEventFilter<StakeAllocatedEvent>;

export interface StakeDepositedEventObject {
  staker: string;
  tokens: BigNumber;
}
export type StakeDepositedEvent = TypedEvent<
  [string, BigNumber],
  StakeDepositedEventObject
>;

export type StakeDepositedEventFilter = TypedEventFilter<StakeDepositedEvent>;

export interface StakeLockedEventObject {
  staker: string;
  tokens: BigNumber;
  until: BigNumber;
}
export type StakeLockedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  StakeLockedEventObject
>;

export type StakeLockedEventFilter = TypedEventFilter<StakeLockedEvent>;

export interface StakeSlashedEventObject {
  staker: string;
  tokens: BigNumber;
  escrowAddress: string;
  slasher: string;
}
export type StakeSlashedEvent = TypedEvent<
  [string, BigNumber, string, string],
  StakeSlashedEventObject
>;

export type StakeSlashedEventFilter = TypedEventFilter<StakeSlashedEvent>;

export interface StakeWithdrawnEventObject {
  staker: string;
  tokens: BigNumber;
}
export type StakeWithdrawnEvent = TypedEvent<
  [string, BigNumber],
  StakeWithdrawnEventObject
>;

export type StakeWithdrawnEventFilter = TypedEventFilter<StakeWithdrawnEvent>;

export interface UpgradedEventObject {
  implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface Staking extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: StakingInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    allocate(
      _escrowAddress: PromiseOrValue<string>,
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    allocations(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber, BigNumber, BigNumber] & {
        escrowAddress: string;
        staker: string;
        tokens: BigNumber;
        createdAt: BigNumber;
        closedAt: BigNumber;
      }
    >;

    closeAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[IStaking.AllocationStructOutput]>;

    getAllocationState(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    getListOfStakers(
      overrides?: CallOverrides
    ): Promise<[string[], Stakes.StakerStructOutput[]]>;

    getStakedTokens(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getStaker(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[Stakes.StakerStructOutput]>;

    hasAvailableStake(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    hasStake(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    initialize(
      _token: PromiseOrValue<string>,
      _minimumStake: PromiseOrValue<BigNumberish>,
      _lockPeriod: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    lockPeriod(overrides?: CallOverrides): Promise<[number]>;

    minimumStake(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    proxiableUUID(overrides?: CallOverrides): Promise<[string]>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rewardPool(overrides?: CallOverrides): Promise<[string]>;

    setLockPeriod(
      _lockPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMinimumStake(
      _minimumStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRewardPool(
      _rewardPool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    slash(
      _slasher: PromiseOrValue<string>,
      _staker: PromiseOrValue<string>,
      _escrowAddress: PromiseOrValue<string>,
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stake(
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    stakes(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        tokensStaked: BigNumber;
        tokensAllocated: BigNumber;
        tokensLocked: BigNumber;
        tokensLockedUntil: BigNumber;
      }
    >;

    token(overrides?: CallOverrides): Promise<[string]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unstake(
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  allocate(
    _escrowAddress: PromiseOrValue<string>,
    _tokens: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  allocations(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [string, string, BigNumber, BigNumber, BigNumber] & {
      escrowAddress: string;
      staker: string;
      tokens: BigNumber;
      createdAt: BigNumber;
      closedAt: BigNumber;
    }
  >;

  closeAllocation(
    _escrowAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAllocation(
    _escrowAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<IStaking.AllocationStructOutput>;

  getAllocationState(
    _escrowAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<number>;

  getListOfStakers(
    overrides?: CallOverrides
  ): Promise<[string[], Stakes.StakerStructOutput[]]>;

  getStakedTokens(
    _staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getStaker(
    _staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<Stakes.StakerStructOutput>;

  hasAvailableStake(
    _staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  hasStake(
    _staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  initialize(
    _token: PromiseOrValue<string>,
    _minimumStake: PromiseOrValue<BigNumberish>,
    _lockPeriod: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isAllocation(
    _escrowAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  lockPeriod(overrides?: CallOverrides): Promise<number>;

  minimumStake(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  proxiableUUID(overrides?: CallOverrides): Promise<string>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rewardPool(overrides?: CallOverrides): Promise<string>;

  setLockPeriod(
    _lockPeriod: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMinimumStake(
    _minimumStake: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRewardPool(
    _rewardPool: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  slash(
    _slasher: PromiseOrValue<string>,
    _staker: PromiseOrValue<string>,
    _escrowAddress: PromiseOrValue<string>,
    _tokens: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stake(
    _tokens: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakers(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  stakes(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      tokensStaked: BigNumber;
      tokensAllocated: BigNumber;
      tokensLocked: BigNumber;
      tokensLockedUntil: BigNumber;
    }
  >;

  token(overrides?: CallOverrides): Promise<string>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unstake(
    _tokens: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    allocate(
      _escrowAddress: PromiseOrValue<string>,
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    allocations(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber, BigNumber, BigNumber] & {
        escrowAddress: string;
        staker: string;
        tokens: BigNumber;
        createdAt: BigNumber;
        closedAt: BigNumber;
      }
    >;

    closeAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    getAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<IStaking.AllocationStructOutput>;

    getAllocationState(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<number>;

    getListOfStakers(
      overrides?: CallOverrides
    ): Promise<[string[], Stakes.StakerStructOutput[]]>;

    getStakedTokens(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getStaker(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<Stakes.StakerStructOutput>;

    hasAvailableStake(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    hasStake(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    initialize(
      _token: PromiseOrValue<string>,
      _minimumStake: PromiseOrValue<BigNumberish>,
      _lockPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    isAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    lockPeriod(overrides?: CallOverrides): Promise<number>;

    minimumStake(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    proxiableUUID(overrides?: CallOverrides): Promise<string>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rewardPool(overrides?: CallOverrides): Promise<string>;

    setLockPeriod(
      _lockPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMinimumStake(
      _minimumStake: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRewardPool(
      _rewardPool: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    slash(
      _slasher: PromiseOrValue<string>,
      _staker: PromiseOrValue<string>,
      _escrowAddress: PromiseOrValue<string>,
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stake(
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    stakes(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        tokensStaked: BigNumber;
        tokensAllocated: BigNumber;
        tokensLocked: BigNumber;
        tokensLockedUntil: BigNumber;
      }
    >;

    token(overrides?: CallOverrides): Promise<string>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    unstake(
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "AdminChanged(address,address)"(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    "AllocationClosed(address,uint256,address,uint256)"(
      staker?: PromiseOrValue<string> | null,
      tokens?: null,
      escrowAddress?: PromiseOrValue<string> | null,
      closedAt?: null
    ): AllocationClosedEventFilter;
    AllocationClosed(
      staker?: PromiseOrValue<string> | null,
      tokens?: null,
      escrowAddress?: PromiseOrValue<string> | null,
      closedAt?: null
    ): AllocationClosedEventFilter;

    "BeaconUpgraded(address)"(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "SetLockPeriod(uint32)"(
      lockPeriod?: PromiseOrValue<BigNumberish> | null
    ): SetLockPeriodEventFilter;
    SetLockPeriod(
      lockPeriod?: PromiseOrValue<BigNumberish> | null
    ): SetLockPeriodEventFilter;

    "SetMinumumStake(uint256)"(
      minimumStake?: PromiseOrValue<BigNumberish> | null
    ): SetMinumumStakeEventFilter;
    SetMinumumStake(
      minimumStake?: PromiseOrValue<BigNumberish> | null
    ): SetMinumumStakeEventFilter;

    "SetRewardPool(address)"(
      rewardPool?: PromiseOrValue<string> | null
    ): SetRewardPoolEventFilter;
    SetRewardPool(
      rewardPool?: PromiseOrValue<string> | null
    ): SetRewardPoolEventFilter;

    "StakeAllocated(address,uint256,address,uint256)"(
      staker?: PromiseOrValue<string> | null,
      tokens?: null,
      escrowAddress?: PromiseOrValue<string> | null,
      createdAt?: null
    ): StakeAllocatedEventFilter;
    StakeAllocated(
      staker?: PromiseOrValue<string> | null,
      tokens?: null,
      escrowAddress?: PromiseOrValue<string> | null,
      createdAt?: null
    ): StakeAllocatedEventFilter;

    "StakeDeposited(address,uint256)"(
      staker?: PromiseOrValue<string> | null,
      tokens?: null
    ): StakeDepositedEventFilter;
    StakeDeposited(
      staker?: PromiseOrValue<string> | null,
      tokens?: null
    ): StakeDepositedEventFilter;

    "StakeLocked(address,uint256,uint256)"(
      staker?: PromiseOrValue<string> | null,
      tokens?: null,
      until?: null
    ): StakeLockedEventFilter;
    StakeLocked(
      staker?: PromiseOrValue<string> | null,
      tokens?: null,
      until?: null
    ): StakeLockedEventFilter;

    "StakeSlashed(address,uint256,address,address)"(
      staker?: PromiseOrValue<string> | null,
      tokens?: null,
      escrowAddress?: PromiseOrValue<string> | null,
      slasher?: null
    ): StakeSlashedEventFilter;
    StakeSlashed(
      staker?: PromiseOrValue<string> | null,
      tokens?: null,
      escrowAddress?: PromiseOrValue<string> | null,
      slasher?: null
    ): StakeSlashedEventFilter;

    "StakeWithdrawn(address,uint256)"(
      staker?: PromiseOrValue<string> | null,
      tokens?: null
    ): StakeWithdrawnEventFilter;
    StakeWithdrawn(
      staker?: PromiseOrValue<string> | null,
      tokens?: null
    ): StakeWithdrawnEventFilter;

    "Upgraded(address)"(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
    Upgraded(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
  };

  estimateGas: {
    allocate(
      _escrowAddress: PromiseOrValue<string>,
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    allocations(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    closeAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAllocationState(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getListOfStakers(overrides?: CallOverrides): Promise<BigNumber>;

    getStakedTokens(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getStaker(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasAvailableStake(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasStake(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      _token: PromiseOrValue<string>,
      _minimumStake: PromiseOrValue<BigNumberish>,
      _lockPeriod: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lockPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    minimumStake(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rewardPool(overrides?: CallOverrides): Promise<BigNumber>;

    setLockPeriod(
      _lockPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMinimumStake(
      _minimumStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRewardPool(
      _rewardPool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    slash(
      _slasher: PromiseOrValue<string>,
      _staker: PromiseOrValue<string>,
      _escrowAddress: PromiseOrValue<string>,
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stake(
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stakes(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    token(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unstake(
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    allocate(
      _escrowAddress: PromiseOrValue<string>,
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    allocations(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    closeAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAllocationState(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getListOfStakers(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getStakedTokens(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getStaker(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasAvailableStake(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasStake(
      _staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      _token: PromiseOrValue<string>,
      _minimumStake: PromiseOrValue<BigNumberish>,
      _lockPeriod: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isAllocation(
      _escrowAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lockPeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minimumStake(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rewardPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setLockPeriod(
      _lockPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMinimumStake(
      _minimumStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRewardPool(
      _rewardPool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    slash(
      _slasher: PromiseOrValue<string>,
      _staker: PromiseOrValue<string>,
      _escrowAddress: PromiseOrValue<string>,
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stake(
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    stakes(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    token(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unstake(
      _tokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
